#include "stdafx.h"
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#define MAXITERATION 1000
//Global Functions
int countPath(int*);//count num of elements
int checkPathAccepted(int*);
int compareArray(int*, int*);//compare tempPath & storePath[] for repetition issue
void heuristicSearch();

//Global Variables
int **table;
int** storePath;//maximum possible paths fit with checkPoints
int numStorePaths;//number of possible paths
int* tempPath; //temporary store path generated by heuristic search
int* shortestPath;
int countAnts = 0;//counter for ants
int row, column, i, j, index, ind, count, choice, prev[2], startPx, startPy;
int startP;//starting no of table
int destP;//destination no of shelve
int checkPoint[30];//table to be passed-by

int main(int argc, char** argv[]) {

	srand(time(NULL));
	//tables

	printf("Number of rows:");//row
	scanf_s("%d", &row);
	printf("Number of columns:");//column
	scanf_s("%d", &column);
	//to create shelves
	//rowxcolumn <= 16 -> 2 shelves
	//rowxcolumn >16 -> 3 shelves
	row++;//to create shelves
		  /**create tables**/

	table = (int **)malloc(row*sizeof(int *));

	for (i = 0; i < row; i++)
	{
		table[i] = (int *)malloc((column)*sizeof(int));
	}

	int num = 1;
	for (i = 0; i < row; i++)
	{
		for (j = 0; j < column; j++)
		{
			if ((row - 1)*column <= 16) {//for 2 shelves
				if ((i == row - 1) && ((j < 1) || (j>2)))
					table[i][j] = 0;//to create row of shelves
				else table[i][j] = num++;//*set no. of tables
			}
			else {//for 3 shelves
				if ((i == row - 1) && ((j < 1) || (j>3)))
					table[i][j] = 0;//to create row of shelves
				else table[i][j] = num++;//*set no. of tables
			}
		}
	}
	for (i = 0; i < row; i++)
	{

		for (j = 0; j < column; j++)
		{
			if (table[i][j] != 0) {
				printf("| %d ", table[i][j]);
			}
			//make 1st column of shelves row empty
			else if ((table[i][j] == 0) && (j == 0)) {
				printf("  ");
			}
		}
		printf("|\n");
	}
	/**End of tables creation**/

	//initialise storePath with zeros
	//storePath=(int *)calloc((row*column)+1,sizeof(int));
	storePath = (int **)malloc(100 * sizeof(int *));

	for (int i = 0; i < 100; i++)
	{
		storePath[i] = (int *)malloc(((row*column) + 1)*sizeof(int));
		storePath[i] = (int *)calloc((row*column) + 1, sizeof(int));

	}

	//create temporary path to store ant's path
	tempPath = (int *)malloc(((row*column) + 1)*sizeof(int));
	//initialise tempPath with zeros
	tempPath = (int *)calloc((row*column) + 1, sizeof(int));


	printf("Input of Starting Point: ");
	scanf_s("%d", &startP,10);


	printf("Input of Destination Point: ");
	scanf_s("%d", &destP,10);

	printf("Input Check Point from 1 - %d\nEnter 0 to stop input.\n", table[row - 2][column - 1]);

	for (i = 0; i < 20; i++) {
		printf("Input of Check Point %d: ", i + 1);
		scanf_s("%d", &checkPoint[i],10);
		if (checkPoint[i] == 0) break;
	}

	i = j = 0;
	index = 0;
	ind = 0;
	count = 0;
	choice = 0;
	//search Starting Point
	for (j = 0; j < column; j++) {
		if (table[i][j] == startP) {//i=0 as only start in 1st row
			prev[0] = i;
			prev[1] = j;
			tempPath[ind] = table[i][j];
			startPx = i;
			startPy = j;
			ind++;
			break;
		}
	}

	heuristicSearch();//generate maximum possible paths with checkpoints
	printf("\n%d", numStorePaths); getchar();
	for (int _numStorePaths = 0; _numStorePaths < numStorePaths; _numStorePaths++) {
		printf("\n");
		for (int ind_storePath = 0; ind_storePath < countPath(storePath[_numStorePaths]); ind_storePath++) {
			printf("%d ", storePath[_numStorePaths][ind_storePath]);
		}
	}

	getchar(); getchar();
	return 0;
}

int countPath(int* arr)
{
	int count = 0;
	while (1)
	{
		if (arr[count] > 0) count++;
		else break;
	}
	return count;
}

int checkPathAccepted(int* temp) {

	int numElementsOfTemp = countPath(temp);
	int numElementsOfCheckP = countPath(checkPoint);
	int ind_tables;
	int numCheckPoint = 0;

	if (temp[numElementsOfTemp - 1] == destP) {

		for (int i = 0; i < numElementsOfTemp - 1; i++)
		{
			ind_tables = 0;

			//check every tempPath element with checkpoint
			while (ind_tables < numElementsOfCheckP) {
				if (temp[i] == checkPoint[ind_tables]) {
					numCheckPoint++;
				}
				ind_tables++;
			}
		}
		//tempPath accepted
		if (numCheckPoint == numElementsOfCheckP) return 1;
		else return 0;//tempPath not accepted
	}
	else return 0;//tempPath not accepted

}

int compareArray(int* arr1, int* arr2)
{
	int ans = 0;//0 = same, 1 = diff
	if (countPath(arr1) != countPath(arr2)) ans = 1;
	else {
		for (int i = 0; i < countPath(arr1); i++)
		{
			if (arr1[i] != arr2[i]) {
				ans = 1;// if diff array
				break;
			}
		}
	}
	return ans;
}

void heuristicSearch()
{
	int iteration = 0;
	numStorePaths = 0;
	while (count < 100) {

		if (i == row - 1)
		{
			//Check path with checkpoints and destination point
			if (checkPathAccepted(tempPath) == 1) {//path fits

												   /**Checking Repeatitation**/
				if (count == 0) {
					storePath[count] = tempPath;
					numStorePaths++;
					count++;
					//printf("Stored!\n");
				}
				else {
					int idx = 0;
					int flag = 1;//to check same path or different, 0=same, 1=different
					while (idx < count) {
						if (compareArray(storePath[idx], tempPath) == 0) {//same path
							flag = 0;
							break;
						}
						else {
							flag = 1;
							idx++;
						}
					}
					if (flag == 1) {//different path
						storePath[count] = tempPath;
						numStorePaths++;
						//printf("Stored!\n");
						count++;
					}
				}
				/**End of Checking Repeatitation**/
			}
			//start new path generation
			tempPath = (int *)calloc((row*column) + 1, sizeof(int));
			//set random seed
			srand(iteration);
			i = startPx; j = startPy;
			ind = 0;
			tempPath[ind] = table[i][j];
			ind++;
			iteration++;
			if (iteration == MAXITERATION) { printf("End of Iteration"); break; }
		}

		choice = rand() % 3 + 1;//3 direction/choice, start from 1
		switch (choice)
		{
		case 1: {	//go LEFT
			if (j == 0) break;// most left position

			else if ((prev[0] == i) && (prev[1] == j - 1)) break;// no turn back
			else {
				prev[0] = i;// store previous step
				prev[1] = j;
				tempPath[ind] = table[i][--j];
				ind++;
				break;
			}
		}
		case 2: {	//go RIGHT
			if (j == column - 1) break;// most right 
			else if ((prev[0] == i) && (prev[1] == j + 1)) break;// no turn back
			else {
				prev[0] = i;
				prev[1] = j;
				tempPath[ind] = table[i][++j];
				ind++;
				break;
			}
		}
		case 3: {		//go BOTTOM
			prev[0] = i;
			prev[1] = j;
			i++;
			if (table[i][j] == 0) {	//if get 0 in last row
				if (j == 0) {
					tempPath[ind] = table[i][j + 1];//if 0 at left
				}
				else tempPath[ind] = table[i][j - 1];//if 0 at right

			}
			else {
				tempPath[ind] = table[i][j];
				ind++;
			}
			break;

		}
		default: printf("wrong\n"); break;
		}


		//count++;
	}
}